"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;

var index_1 = require("./index");

var url_1 = require("url");

var path_1 = require("path");

var assert = require("assert");

var util_1 = require("./util");

var module_1 = require("module");

var _require = require('../dist-raw/node-esm-resolve-implementation'),
    createResolve = _require.createResolve;

var _require2 = require('../dist-raw/node-esm-default-get-format'),
    defaultGetFormat = _require2.defaultGetFormat; // The hooks API changed in node version X so we need to check for backwards compatibility.
// TODO: When the new API is backported to v12, v14, update these version checks accordingly.


var newHooksAPI = (0, index_1.versionGteLt)(process.versions.node, '17.0.0') || (0, index_1.versionGteLt)(process.versions.node, '16.12.0', '17.0.0') || (0, index_1.versionGteLt)(process.versions.node, '14.999.999', '15.0.0') || (0, index_1.versionGteLt)(process.versions.node, '12.999.999', '13.0.0');
/** @internal */

function filterHooksByAPIVersion(hooks) {
  var getFormat = hooks.getFormat,
      load = hooks.load,
      resolve = hooks.resolve,
      transformSource = hooks.transformSource; // Explicit return type to avoid TS's non-ideal inferred type

  var hooksAPI = newHooksAPI ? {
    resolve: resolve,
    load: load,
    getFormat: undefined,
    transformSource: undefined
  } : {
    resolve: resolve,
    getFormat: getFormat,
    transformSource: transformSource,
    load: undefined
  };
  return hooksAPI;
}

exports.filterHooksByAPIVersion = filterHooksByAPIVersion;
/** @internal */

function registerAndCreateEsmHooks(opts) {
  // Automatically performs registration just like `-r ts-node/register`
  var tsNodeInstance = (0, index_1.register)(opts);
  return createEsmHooks(tsNodeInstance);
}

exports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;

function createEsmHooks(tsNodeService) {
  tsNodeService.enableExperimentalEsmLoaderInterop(); // Custom implementation that considers additional file extensions and automatically adds file extensions

  var nodeResolveImplementation = createResolve(_objectSpread({}, (0, index_1.getExtensions)(tsNodeService.config), {
    preferTsExts: tsNodeService.options.preferTsExts
  }));
  var hooksAPI = filterHooksByAPIVersion({
    resolve: resolve,
    load: load,
    getFormat: getFormat,
    transformSource: transformSource
  });

  function isFileUrlOrNodeStyleSpecifier(parsed) {
    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`
    var protocol = parsed.protocol;
    return protocol === null || protocol === 'file:';
  }
  /**
   * Named "probably" as a reminder that this is a guess.
   * node does not explicitly tell us if we're resolving the entrypoint or not.
   */


  function isProbablyEntrypoint(specifier, parentURL) {
    return parentURL === undefined && specifier.startsWith('file://');
  } // Side-channel between `resolve()` and `load()` hooks


  var rememberIsProbablyEntrypoint = new Set();
  var rememberResolvedViaCommonjsFallback = new Set();

  function resolve(specifier, context, defaultResolve) {
    var defer, entrypointFallback, parsed, pathname, protocol, hostname;
    return regeneratorRuntime.async(function resolve$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            entrypointFallback = function _ref(cb) {
              var resolution, cjsSpecifier, _resolution;

              return regeneratorRuntime.async(function entrypointFallback$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.prev = 0;
                      _context3.next = 3;
                      return regeneratorRuntime.awrap(cb());

                    case 3:
                      resolution = _context3.sent;
                      if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL)) rememberIsProbablyEntrypoint.add(resolution.url);
                      return _context3.abrupt("return", resolution);

                    case 8:
                      _context3.prev = 8;
                      _context3.t0 = _context3["catch"](0);

                      if (isProbablyEntrypoint(specifier, context.parentURL)) {
                        _context3.next = 12;
                        break;
                      }

                      throw _context3.t0;

                    case 12:
                      _context3.prev = 12;
                      cjsSpecifier = specifier; // Attempt to convert from ESM file:// to CommonJS path

                      try {
                        if (specifier.startsWith('file://')) cjsSpecifier = (0, url_1.fileURLToPath)(specifier);
                      } catch (_unused) {}

                      _resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();
                      rememberIsProbablyEntrypoint.add(_resolution);
                      rememberResolvedViaCommonjsFallback.add(_resolution);
                      return _context3.abrupt("return", {
                        url: _resolution,
                        format: 'commonjs'
                      });

                    case 21:
                      _context3.prev = 21;
                      _context3.t1 = _context3["catch"](12);
                      throw _context3.t0;

                    case 24:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, null, null, [[0, 8], [12, 21]]);
            };

            defer = function defer() {
              var r;
              return regeneratorRuntime.async(function defer$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return regeneratorRuntime.awrap(defaultResolve(specifier, context, defaultResolve));

                    case 2:
                      r = _context2.sent;
                      return _context2.abrupt("return", r);

                    case 4:
                    case "end":
                      return _context2.stop();
                  }
                }
              });
            }; // See: https://github.com/nodejs/node/discussions/41711
            // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.


            parsed = (0, url_1.parse)(specifier);
            pathname = parsed.pathname, protocol = parsed.protocol, hostname = parsed.hostname;

            if (isFileUrlOrNodeStyleSpecifier(parsed)) {
              _context4.next = 6;
              break;
            }

            return _context4.abrupt("return", entrypointFallback(defer));

          case 6:
            if (!(protocol !== null && protocol !== 'file:')) {
              _context4.next = 8;
              break;
            }

            return _context4.abrupt("return", entrypointFallback(defer));

          case 8:
            if (!hostname) {
              _context4.next = 10;
              break;
            }

            return _context4.abrupt("return", entrypointFallback(defer));

          case 10:
            return _context4.abrupt("return", entrypointFallback(function () {
              return nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve);
            }));

          case 11:
          case "end":
            return _context4.stop();
        }
      }
    });
  } // `load` from new loader hook API (See description at the top of this file)


  function load(url, context, defaultLoad) {
    var _a, format, source, _ref2, rawSource, defaultTransformSource, _ref3, transformedSource;

    return regeneratorRuntime.async(function load$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!((_a = context.format) !== null && _a !== void 0)) {
              _context6.next = 4;
              break;
            }

            _context6.t0 = _a;
            _context6.next = 7;
            break;

          case 4:
            _context6.next = 6;
            return regeneratorRuntime.awrap(getFormat(url, context, defaultGetFormat));

          case 6:
            _context6.t0 = _context6.sent.format;

          case 7:
            format = _context6.t0;
            source = undefined;

            if (!(format !== 'builtin' && format !== 'commonjs')) {
              _context6.next = 22;
              break;
            }

            _context6.next = 12;
            return regeneratorRuntime.awrap(defaultLoad(url, _objectSpread({}, context, {
              format: format
            }), defaultLoad));

          case 12:
            _ref2 = _context6.sent;
            rawSource = _ref2.source;

            if (!(rawSource === undefined || rawSource === null)) {
              _context6.next = 16;
              break;
            }

            throw new Error("Failed to load raw source: Format was '".concat(format, "' and url was '").concat(url, "''."));

          case 16:
            // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook
            defaultTransformSource = function defaultTransformSource(source, _context, _defaultTransformSource) {
              return regeneratorRuntime.async(function defaultTransformSource$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      return _context5.abrupt("return", {
                        source: source
                      });

                    case 1:
                    case "end":
                      return _context5.stop();
                  }
                }
              });
            }; // Call the old hook


            _context6.next = 19;
            return regeneratorRuntime.awrap(transformSource(rawSource, {
              url: url,
              format: format
            }, defaultTransformSource));

          case 19:
            _ref3 = _context6.sent;
            transformedSource = _ref3.source;
            source = transformedSource;

          case 22:
            return _context6.abrupt("return", {
              format: format,
              source: source
            });

          case 23:
          case "end":
            return _context6.stop();
        }
      }
    });
  }

  function getFormat(url, context, defaultGetFormat) {
    var defer, entrypointFallback, parsed, pathname, nativePath, ext, nodeSays, _tsNodeService$module, moduleType;

    return regeneratorRuntime.async(function getFormat$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            entrypointFallback = function _ref4(cb) {
              return regeneratorRuntime.async(function entrypointFallback$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.prev = 0;
                      _context7.next = 3;
                      return regeneratorRuntime.awrap(cb());

                    case 3:
                      return _context7.abrupt("return", _context7.sent);

                    case 6:
                      _context7.prev = 6;
                      _context7.t0 = _context7["catch"](0);

                      if (rememberIsProbablyEntrypoint.has(url)) {
                        _context7.next = 10;
                        break;
                      }

                      throw _context7.t0;

                    case 10:
                      return _context7.abrupt("return", {
                        format: 'commonjs'
                      });

                    case 11:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, null, null, [[0, 6]]);
            };

            defer = function defer() {
              var overrideUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;
              return defaultGetFormat(overrideUrl, context, defaultGetFormat);
            }; // See: https://github.com/nodejs/node/discussions/41711
            // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.


            parsed = (0, url_1.parse)(url);

            if (isFileUrlOrNodeStyleSpecifier(parsed)) {
              _context8.next = 5;
              break;
            }

            return _context8.abrupt("return", entrypointFallback(defer));

          case 5:
            pathname = parsed.pathname;
            assert(pathname !== null, 'ESM getFormat() hook: URL should never have null pathname');
            nativePath = (0, url_1.fileURLToPath)(url); // If file has .ts, .tsx, or .jsx extension, then ask node how it would treat this file if it were .js

            ext = (0, path_1.extname)(nativePath);

            if (!(ext !== '.js' && !tsNodeService.ignored(nativePath))) {
              _context8.next = 15;
              break;
            }

            _context8.next = 12;
            return regeneratorRuntime.awrap(entrypointFallback(function () {
              return defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + '.js')));
            }));

          case 12:
            nodeSays = _context8.sent;
            _context8.next = 18;
            break;

          case 15:
            _context8.next = 17;
            return regeneratorRuntime.awrap(entrypointFallback(defer));

          case 17:
            nodeSays = _context8.sent;

          case 18:
            if (!(!tsNodeService.ignored(nativePath) && (nodeSays.format === 'commonjs' || nodeSays.format === 'module'))) {
              _context8.next = 26;
              break;
            }

            _tsNodeService$module = tsNodeService.moduleTypeClassifier.classifyModule((0, util_1.normalizeSlashes)(nativePath)), moduleType = _tsNodeService$module.moduleType;

            if (!(moduleType === 'cjs')) {
              _context8.next = 24;
              break;
            }

            return _context8.abrupt("return", {
              format: 'commonjs'
            });

          case 24:
            if (!(moduleType === 'esm')) {
              _context8.next = 26;
              break;
            }

            return _context8.abrupt("return", {
              format: 'module'
            });

          case 26:
            return _context8.abrupt("return", nodeSays);

          case 27:
          case "end":
            return _context8.stop();
        }
      }
    });
  }

  function transformSource(source, context, defaultTransformSource) {
    var defer, sourceAsString, url, parsed, nativePath, emittedJs;
    return regeneratorRuntime.async(function transformSource$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            if (!(source === null || source === undefined)) {
              _context9.next = 2;
              break;
            }

            throw new Error('No source');

          case 2:
            defer = function defer() {
              return defaultTransformSource(source, context, defaultTransformSource);
            };

            sourceAsString = typeof source === 'string' ? source : source.toString('utf8');
            url = context.url;
            parsed = (0, url_1.parse)(url);

            if (isFileUrlOrNodeStyleSpecifier(parsed)) {
              _context9.next = 8;
              break;
            }

            return _context9.abrupt("return", defer());

          case 8:
            nativePath = (0, url_1.fileURLToPath)(url);

            if (!tsNodeService.ignored(nativePath)) {
              _context9.next = 11;
              break;
            }

            return _context9.abrupt("return", defer());

          case 11:
            emittedJs = tsNodeService.compile(sourceAsString, nativePath);
            return _context9.abrupt("return", {
              source: emittedJs
            });

          case 13:
          case "end":
            return _context9.stop();
        }
      }
    });
  }

  return hooksAPI;
}

exports.createEsmHooks = createEsmHooks;