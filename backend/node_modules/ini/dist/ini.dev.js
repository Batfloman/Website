"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var hasOwnProperty = Object.prototype.hasOwnProperty;
var eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\r\n' : '\n';

var encode = function encode(obj, opt) {
  var children = [];
  var out = '';

  if (typeof opt === 'string') {
    opt = {
      section: opt,
      whitespace: false
    };
  } else {
    opt = opt || Object.create(null);
    opt.whitespace = opt.whitespace === true;
  }

  var separator = opt.whitespace ? ' = ' : '=';

  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
    var k = _Object$keys[_i];
    var val = obj[k];

    if (val && Array.isArray(val)) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = val[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          out += safe(k + '[]') + separator + safe(item) + '\n';
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    } else if (val && _typeof(val) === 'object') children.push(k);else out += safe(k) + separator + safe(val) + eol;
  }

  if (opt.section && out.length) out = '[' + safe(opt.section) + ']' + eol + out;

  for (var _i2 = 0, _children = children; _i2 < _children.length; _i2++) {
    var _k = _children[_i2];
    var nk = dotSplit(_k).join('\\.');
    var section = (opt.section ? opt.section + '.' : '') + nk;
    var _opt = opt,
        whitespace = _opt.whitespace;
    var child = encode(obj[_k], {
      section: section,
      whitespace: whitespace
    });
    if (out.length && child.length) out += eol;
    out += child;
  }

  return out;
};

var dotSplit = function dotSplit(str) {
  return str.replace(/\1/g, "\x02LITERAL\\1LITERAL\x02").replace(/\\\./g, "\x01").split(/\./).map(function (part) {
    return part.replace(/\1/g, '\\.').replace(/\2LITERAL\\1LITERAL\2/g, "\x01");
  });
};

var decode = function decode(str) {
  var out = Object.create(null);
  var p = out;
  var section = null; //          section     |key      = value

  var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
  var lines = str.split(/[\r\n]+/g);
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var line = _step2.value;
      if (!line || line.match(/^\s*[;#]/)) continue;
      var match = line.match(re);
      if (!match) continue;

      if (match[1] !== undefined) {
        section = unsafe(match[1]);

        if (section === '__proto__') {
          // not allowed
          // keep parsing the section, but don't attach it.
          p = Object.create(null);
          continue;
        }

        p = out[section] = out[section] || Object.create(null);
        continue;
      }

      var keyRaw = unsafe(match[2]);
      var isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]';
      var key = isArray ? keyRaw.slice(0, -2) : keyRaw;
      if (key === '__proto__') continue;
      var valueRaw = match[3] ? unsafe(match[4]) : true;
      var value = valueRaw === 'true' || valueRaw === 'false' || valueRaw === 'null' ? JSON.parse(valueRaw) : valueRaw; // Convert keys with '[]' suffix to an array

      if (isArray) {
        if (!hasOwnProperty.call(p, key)) p[key] = [];else if (!Array.isArray(p[key])) p[key] = [p[key]];
      } // safeguard against resetting a previously defined
      // array by accidentally forgetting the brackets


      if (Array.isArray(p[key])) p[key].push(value);else p[key] = value;
    } // {a:{y:1},"a.b":{x:2}} --> {a:{y:1,b:{x:2}}}
    // use a filter to return the keys that have to be deleted.

  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var remove = [];

  for (var _i3 = 0, _Object$keys2 = Object.keys(out); _i3 < _Object$keys2.length; _i3++) {
    var k = _Object$keys2[_i3];
    if (!hasOwnProperty.call(out, k) || _typeof(out[k]) !== 'object' || Array.isArray(out[k])) continue; // see if the parent section is also an object.
    // if so, add it to that, and mark this one for deletion

    var parts = dotSplit(k);
    var _p = out;
    var l = parts.pop();
    var nl = l.replace(/\\\./g, '.');
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = parts[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var part = _step3.value;
        if (part === '__proto__') continue;
        if (!hasOwnProperty.call(_p, part) || _typeof(_p[part]) !== 'object') _p[part] = Object.create(null);
        _p = _p[part];
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    if (_p === out && nl === l) continue;
    _p[nl] = out[k];
    remove.push(k);
  }

  for (var _i4 = 0, _remove = remove; _i4 < _remove.length; _i4++) {
    var del = _remove[_i4];
    delete out[del];
  }

  return out;
};

var isQuoted = function isQuoted(val) {
  return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
};

var safe = function safe(val) {
  return typeof val !== 'string' || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, '\\;').replace(/#/g, '\\#');
};

var unsafe = function unsafe(val, doUnesc) {
  val = (val || '').trim();

  if (isQuoted(val)) {
    // remove the single quotes before calling JSON.parse
    if (val.charAt(0) === "'") val = val.substr(1, val.length - 2);

    try {
      val = JSON.parse(val);
    } catch (_) {}
  } else {
    // walk the val to find the first not-escaped ; character
    var esc = false;
    var unesc = '';

    for (var i = 0, l = val.length; i < l; i++) {
      var c = val.charAt(i);

      if (esc) {
        if ('\\;#'.indexOf(c) !== -1) unesc += c;else unesc += '\\' + c;
        esc = false;
      } else if (';#'.indexOf(c) !== -1) break;else if (c === '\\') esc = true;else unesc += c;
    }

    if (esc) unesc += '\\';
    return unesc.trim();
  }

  return val;
};

module.exports = {
  parse: decode,
  decode: decode,
  stringify: encode,
  encode: encode,
  safe: safe,
  unsafe: unsafe
};