'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var stringWidth = require('string-width');

var chalk = require('chalk');

var widestLine = require('widest-line');

var cliBoxes = require('cli-boxes');

var camelCase = require('camelcase');

var ansiAlign = require('ansi-align');

var wrapAnsi = require('wrap-ansi');

var NL = '\n';
var PAD = ' ';

var terminalColumns = function terminalColumns() {
  var _process = process,
      env = _process.env,
      stdout = _process.stdout,
      stderr = _process.stderr;

  if (stdout && stdout.columns) {
    return stdout.columns;
  }

  if (stderr && stderr.columns) {
    return stderr.columns;
  }

  if (env.COLUMNS) {
    return Number.parseInt(env.COLUMNS, 10);
  }

  return 80;
};

var getObject = function getObject(detail) {
  return typeof detail === 'number' ? {
    top: detail,
    right: detail * 3,
    bottom: detail,
    left: detail * 3
  } : _objectSpread({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, detail);
};

var getBorderChars = function getBorderChars(borderStyle) {
  var sides = ['topLeft', 'topRight', 'bottomRight', 'bottomLeft', 'vertical', 'horizontal'];
  var chararacters;

  if (typeof borderStyle === 'string') {
    chararacters = cliBoxes[borderStyle];

    if (!chararacters) {
      throw new TypeError("Invalid border style: ".concat(borderStyle));
    }
  } else {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = sides[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var side = _step.value;

        if (!borderStyle[side] || typeof borderStyle[side] !== 'string') {
          throw new TypeError("Invalid border style: ".concat(side));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    chararacters = borderStyle;
  }

  return chararacters;
};

var makeTitle = function makeTitle(text, horizontal, alignement) {
  var title = '';
  var textWidth = stringWidth(text);

  switch (alignement) {
    case 'left':
      title = text + horizontal.slice(textWidth);
      break;

    case 'right':
      title = horizontal.slice(textWidth) + text;
      break;

    default:
      horizontal = horizontal.slice(textWidth);

      if (horizontal.length % 2 === 1) {
        // This is needed in case the length is odd
        horizontal = horizontal.slice(Math.floor(horizontal.length / 2));
        title = horizontal.slice(1) + text + horizontal; // We reduce the left part of one character to avoid the bar to go beyond its limit
      } else {
        horizontal = horizontal.slice(horizontal.length / 2);
        title = horizontal + text + horizontal;
      }

      break;
  }

  return title;
};

var makeContentText = function makeContentText(text, padding, columns, align) {
  text = ansiAlign(text, {
    align: align
  });
  var lines = text.split(NL);
  var textWidth = widestLine(text);
  var max = columns - padding.left - padding.right;

  if (textWidth > max) {
    var newLines = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var line = _step2.value;
        var createdLines = wrapAnsi(line, max, {
          hard: true
        });
        var alignedLines = ansiAlign(createdLines, {
          align: align
        });
        var alignedLinesArray = alignedLines.split('\n');
        var longestLength = Math.max.apply(Math, _toConsumableArray(alignedLinesArray.map(function (s) {
          return stringWidth(s);
        })));
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = alignedLinesArray[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var alignedLine = _step3.value;
            var paddedLine = void 0;

            switch (align) {
              case 'center':
                paddedLine = PAD.repeat((max - longestLength) / 2) + alignedLine;
                break;

              case 'right':
                paddedLine = PAD.repeat(max - longestLength) + alignedLine;
                break;

              default:
                paddedLine = alignedLine;
                break;
            }

            newLines.push(paddedLine);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    lines = newLines;
  }

  if (align === 'center' && textWidth < max) {
    lines = lines.map(function (line) {
      return PAD.repeat((max - textWidth) / 2) + line;
    });
  } else if (align === 'right' && textWidth < max) {
    lines = lines.map(function (line) {
      return PAD.repeat(max - textWidth) + line;
    });
  }

  var paddingLeft = PAD.repeat(padding.left);
  var paddingRight = PAD.repeat(padding.right);
  lines = lines.map(function (line) {
    return paddingLeft + line + paddingRight;
  });
  lines = lines.map(function (line) {
    if (columns - stringWidth(line) > 0) {
      switch (align) {
        case 'center':
          return line + PAD.repeat(columns - stringWidth(line));

        case 'right':
          return line + PAD.repeat(columns - stringWidth(line));

        default:
          return line + PAD.repeat(columns - stringWidth(line));
      }
    }

    return line;
  });

  if (padding.top > 0) {
    lines = new Array(padding.top).fill(PAD.repeat(columns)).concat(lines);
  }

  if (padding.bottom > 0) {
    lines = lines.concat(new Array(padding.bottom).fill(PAD.repeat(columns)));
  }

  return lines.join(NL);
};

var isHex = function isHex(color) {
  return color.match(/^#(?:[0-f]{3}){1,2}$/i);
};

var isColorValid = function isColorValid(color) {
  return typeof color === 'string' && (chalk[color] || isHex(color));
};

var getColorFn = function getColorFn(color) {
  return isHex(color) ? chalk.hex(color) : chalk[color];
};

var getBGColorFn = function getBGColorFn(color) {
  return isHex(color) ? chalk.bgHex(color) : chalk[camelCase(['bg', color])];
};

module.exports = function (text, options) {
  options = _objectSpread({
    padding: 0,
    borderStyle: 'single',
    dimBorder: false,
    textAlignment: 'left',
    "float": 'left',
    titleAlignment: 'left'
  }, options); // This option is deprecated

  if (options.align) {
    options.textAlignment = options.align;
  }

  var BORDERS_WIDTH = 2;

  if (options.borderColor && !isColorValid(options.borderColor)) {
    throw new Error("".concat(options.borderColor, " is not a valid borderColor"));
  }

  if (options.backgroundColor && !isColorValid(options.backgroundColor)) {
    throw new Error("".concat(options.backgroundColor, " is not a valid backgroundColor"));
  }

  var chars = getBorderChars(options.borderStyle);
  var padding = getObject(options.padding);
  var margin = getObject(options.margin);

  var colorizeBorder = function colorizeBorder(border) {
    var newBorder = options.borderColor ? getColorFn(options.borderColor)(border) : border;
    return options.dimBorder ? chalk.dim(newBorder) : newBorder;
  };

  var colorizeContent = function colorizeContent(content) {
    return options.backgroundColor ? getBGColorFn(options.backgroundColor)(content) : content;
  };

  var columns = terminalColumns();
  var contentWidth = widestLine(wrapAnsi(text, columns - BORDERS_WIDTH, {
    hard: true,
    trim: false
  })) + padding.left + padding.right; // This prevents the title bar to exceed the console's width

  var title = options.title && options.title.slice(0, columns - 4 - margin.left - margin.right);

  if (title) {
    title = " ".concat(title, " "); // Make the box larger to fit a larger title

    if (stringWidth(title) > contentWidth) {
      contentWidth = stringWidth(title);
    }
  }

  if (margin.left && margin.right && contentWidth + BORDERS_WIDTH + margin.left + margin.right > columns) {
    // Let's assume we have margins: left = 3, right = 5, in total = 8
    var spaceForMargins = columns - contentWidth - BORDERS_WIDTH; // Let's assume we have space = 4

    var multiplier = spaceForMargins / (margin.left + margin.right); // Here: multiplier = 4/8 = 0.5

    margin.left = Math.max(0, Math.floor(margin.left * multiplier));
    margin.right = Math.max(0, Math.floor(margin.right * multiplier)); // Left: 3 * 0.5 = 1.5 -> 1
    // Right: 6 * 0.5 = 3
  } // Prevent content from exceeding the console's width


  contentWidth = Math.min(contentWidth, columns - BORDERS_WIDTH - margin.left - margin.right);
  text = makeContentText(text, padding, contentWidth, options.textAlignment);
  var marginLeft = PAD.repeat(margin.left);

  if (options["float"] === 'center') {
    var marginWidth = Math.max((columns - contentWidth - BORDERS_WIDTH) / 2, 0);
    marginLeft = PAD.repeat(marginWidth);
  } else if (options["float"] === 'right') {
    var _marginWidth = Math.max(columns - contentWidth - margin.right - BORDERS_WIDTH, 0);

    marginLeft = PAD.repeat(_marginWidth);
  }

  var horizontal = chars.horizontal.repeat(contentWidth);
  var top = colorizeBorder(NL.repeat(margin.top) + marginLeft + chars.topLeft + (title ? makeTitle(title, horizontal, options.titleAlignment) : horizontal) + chars.topRight);
  var bottom = colorizeBorder(marginLeft + chars.bottomLeft + horizontal + chars.bottomRight + NL.repeat(margin.bottom));
  var side = colorizeBorder(chars.vertical);
  var LINE_SEPARATOR = contentWidth + BORDERS_WIDTH + margin.left >= columns ? '' : NL;
  var lines = text.split(NL);
  var middle = lines.map(function (line) {
    return marginLeft + side + colorizeContent(line) + side;
  }).join(LINE_SEPARATOR);
  return top + LINE_SEPARATOR + middle + LINE_SEPARATOR + bottom;
};

module.exports._borderStyles = cliBoxes;