"use strict";

var readWasm = require("../lib/read-wasm");
/**
 * Provide the JIT with a nice shape / hidden class.
 */


function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.lastGeneratedColumn = null;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

var _cachedWasm = null;
var cachedWasmSync = null;

module.exports = function wasm() {
  return regeneratorRuntime.async(function wasm$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!_cachedWasm) {
            _context2.next = 2;
            break;
          }

          return _context2.abrupt("return", _cachedWasm);

        case 2:
          // At every step of the way, if a sync load already succeeded, abort and return
          // the sync-loaded module.
          _cachedWasm = function cachedWasm() {
            var callbackStack, buffer, Wasm;
            return regeneratorRuntime.async(function cachedWasm$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.prev = 0;
                    callbackStack = [];
                    _context.next = 4;
                    return regeneratorRuntime.awrap(readWasm());

                  case 4:
                    buffer = _context.sent;

                    if (!cachedWasmSync) {
                      _context.next = 7;
                      break;
                    }

                    return _context.abrupt("return", cachedWasmSync);

                  case 7:
                    _context.next = 9;
                    return regeneratorRuntime.awrap(WebAssembly.instantiate(buffer, getImportObject({
                      callbackStack: callbackStack
                    })));

                  case 9:
                    Wasm = _context.sent;

                    if (!cachedWasmSync) {
                      _context.next = 12;
                      break;
                    }

                    return _context.abrupt("return", cachedWasmSync);

                  case 12:
                    cachedWasmSync = {
                      exports: Wasm.instance.exports,
                      withMappingCallback: function withMappingCallback(mappingCallback, f) {
                        callbackStack.push(mappingCallback);

                        try {
                          f();
                        } finally {
                          callbackStack.pop();
                        }
                      }
                    };
                    _context.next = 21;
                    break;

                  case 15:
                    _context.prev = 15;
                    _context.t0 = _context["catch"](0);

                    if (!cachedWasmSync) {
                      _context.next = 19;
                      break;
                    }

                    return _context.abrupt("return", cachedWasmSync);

                  case 19:
                    _cachedWasm = null;
                    throw _context.t0;

                  case 21:
                    return _context.abrupt("return", cachedWasmSync);

                  case 22:
                  case "end":
                    return _context.stop();
                }
              }
            }, null, null, [[0, 15]]);
          };

          return _context2.abrupt("return", _cachedWasm);

        case 4:
        case "end":
          return _context2.stop();
      }
    }
  });
};

module.exports.sync = function wasmSync() {
  if (cachedWasmSync) {
    return cachedWasmSync;
  }

  var callbackStack = [];

  try {
    var cachedWasmBuffer = readWasm.sync();
    var wasmModule = new WebAssembly.Module(cachedWasmBuffer);
    var Wasm = new WebAssembly.Instance(wasmModule, getImportObject({
      callbackStack: callbackStack
    }));
    cachedWasmSync = {
      exports: Wasm.exports,
      withMappingCallback: function withMappingCallback(mappingCallback, f) {
        callbackStack.push(mappingCallback);

        try {
          f();
        } finally {
          callbackStack.pop();
        }
      }
    };
  } catch (e) {
    cachedWasmSync = null;
    throw e;
  }

  return cachedWasmSync;
};

function getImportObject(_ref) {
  var callbackStack = _ref.callbackStack;
  return {
    env: {
      mapping_callback: function mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {
        var mapping = new Mapping(); // JS uses 1-based line numbers, wasm uses 0-based.

        mapping.generatedLine = generatedLine + 1;
        mapping.generatedColumn = generatedColumn;

        if (hasLastGeneratedColumn) {
          // JS uses inclusive last generated column, wasm uses exclusive.
          mapping.lastGeneratedColumn = lastGeneratedColumn - 1;
        }

        if (hasOriginal) {
          mapping.source = source; // JS uses 1-based line numbers, wasm uses 0-based.

          mapping.originalLine = originalLine + 1;
          mapping.originalColumn = originalColumn;

          if (hasName) {
            mapping.name = name;
          }
        }

        callbackStack[callbackStack.length - 1](mapping);
      },
      start_all_generated_locations_for: function start_all_generated_locations_for() {
        console.time("all_generated_locations_for");
      },
      end_all_generated_locations_for: function end_all_generated_locations_for() {
        console.timeEnd("all_generated_locations_for");
      },
      start_compute_column_spans: function start_compute_column_spans() {
        console.time("compute_column_spans");
      },
      end_compute_column_spans: function end_compute_column_spans() {
        console.timeEnd("compute_column_spans");
      },
      start_generated_location_for: function start_generated_location_for() {
        console.time("generated_location_for");
      },
      end_generated_location_for: function end_generated_location_for() {
        console.timeEnd("generated_location_for");
      },
      start_original_location_for: function start_original_location_for() {
        console.time("original_location_for");
      },
      end_original_location_for: function end_original_location_for() {
        console.timeEnd("original_location_for");
      },
      start_parse_mappings: function start_parse_mappings() {
        console.time("parse_mappings");
      },
      end_parse_mappings: function end_parse_mappings() {
        console.timeEnd("parse_mappings");
      },
      start_sort_by_generated_location: function start_sort_by_generated_location() {
        console.time("sort_by_generated_location");
      },
      end_sort_by_generated_location: function end_sort_by_generated_location() {
        console.timeEnd("sort_by_generated_location");
      },
      start_sort_by_original_location: function start_sort_by_original_location() {
        console.time("sort_by_original_location");
      },
      end_sort_by_original_location: function end_sort_by_original_location() {
        console.timeEnd("sort_by_original_location");
      }
    }
  };
}