"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _a, _b;

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.getExtensions = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.versionGteLt = exports.createRepl = void 0;

var path_1 = require("path");

var module_1 = require("module");

var util = require("util");

var url_1 = require("url");

var make_error_1 = require("make-error");

var util_1 = require("./util");

var configuration_1 = require("./configuration");

var module_type_classifier_1 = require("./module-type-classifier");

var resolver_functions_1 = require("./resolver-functions");

var cjs_resolve_filename_hook_1 = require("./cjs-resolve-filename-hook");

var repl_1 = require("./repl");

Object.defineProperty(exports, "createRepl", {
  enumerable: true,
  get: function get() {
    return repl_1.createRepl;
  }
});
/**
 * Does this version of node obey the package.json "type" field
 * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.
 */

var engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;
/** @internal */

function versionGteLt(version, gteRequirement, ltRequirement) {
  var _parse = parse(version),
      _parse2 = _slicedToArray(_parse, 4),
      major = _parse2[0],
      minor = _parse2[1],
      patch = _parse2[2],
      extra = _parse2[3];

  var _parse3 = parse(gteRequirement),
      _parse4 = _slicedToArray(_parse3, 3),
      gteMajor = _parse4[0],
      gteMinor = _parse4[1],
      gtePatch = _parse4[2];

  var isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);
  var isLt = true;

  if (ltRequirement) {
    var _parse5 = parse(ltRequirement),
        _parse6 = _slicedToArray(_parse5, 3),
        ltMajor = _parse6[0],
        ltMinor = _parse6[1],
        ltPatch = _parse6[2];

    isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);
  }

  return isGte && isLt;

  function parse(requirement) {
    return requirement.split(/[\.-]/).map(function (s) {
      return parseInt(s, 10);
    });
  }
}

exports.versionGteLt = versionGteLt;
/**
 * Assert that script can be loaded as CommonJS when we attempt to require it.
 * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.
 *
 * Loaded conditionally so we don't need to support older node versions
 */

var assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require('../dist-raw/node-cjs-loader-utils').assertScriptCanLoadAsCJSImpl : function () {
  /* noop */
};
/**
 * Registered `ts-node` instance information.
 */

exports.REGISTER_INSTANCE = Symbol["for"]('ts-node.register.instance');
/** @internal */

exports.env = process.env;
/**
 * @internal
 */

exports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';
/**
 * Debugging `ts-node`.
 */

var shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);
/** @internal */

exports.debug = shouldDebug ? function () {
  var _console;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return (_console = console).log.apply(_console, ["[ts-node ".concat(new Date().toISOString(), "]")].concat(args));
} : function () {
  return undefined;
};
var debugFn = shouldDebug ? function (key, fn) {
  var i = 0;
  return function (x) {
    (0, exports.debug)(key, x, ++i);
    return fn(x);
  };
} : function (_, fn) {
  return fn;
};
/**
 * Export the current version.
 */

exports.VERSION = require('../package.json').version;
/**
 * Default register options, including values specified via environment
 * variables.
 * @internal
 */

exports.DEFAULTS = {
  cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,
  emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),
  scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),
  scopeDir: exports.env.TS_NODE_SCOPE_DIR,
  files: (0, util_1.yn)(exports.env.TS_NODE_FILES),
  pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),
  compiler: exports.env.TS_NODE_COMPILER,
  compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),
  ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),
  project: exports.env.TS_NODE_PROJECT,
  skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),
  skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),
  preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),
  ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),
  transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),
  typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),
  compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),
  logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),
  experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,
  tsTrace: console.log.bind(console)
};
/**
 * TypeScript diagnostics error.
 */

var TSError =
/*#__PURE__*/
function (_make_error_1$BaseErr) {
  _inherits(TSError, _make_error_1$BaseErr);

  function TSError(diagnosticText, diagnosticCodes) {
    var _this;

    _classCallCheck(this, TSError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TSError).call(this, "\u2A2F Unable to compile TypeScript:\n".concat(diagnosticText)));
    _this.diagnosticCodes = diagnosticCodes;
    _this.name = 'TSError';
    Object.defineProperty(_assertThisInitialized(_this), 'diagnosticText', {
      configurable: true,
      writable: true,
      value: diagnosticText
    });
    return _this;
  }
  /**
   * @internal
   */


  _createClass(TSError, [{
    key: exports.INSPECT_CUSTOM,
    value: function value() {
      return this.diagnosticText;
    }
  }]);

  return TSError;
}(make_error_1.BaseError);

exports.TSError = TSError;
var TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');
/** @internal */

function getExtensions(config) {
  var tsExtensions = ['.ts'];
  var jsExtensions = []; // Enable additional extensions when JSX or `allowJs` is enabled.

  if (config.options.jsx) tsExtensions.push('.tsx');
  if (config.options.allowJs) jsExtensions.push('.js');
  if (config.options.jsx && config.options.allowJs) jsExtensions.push('.jsx');
  return {
    tsExtensions: tsExtensions,
    jsExtensions: jsExtensions
  };
}

exports.getExtensions = getExtensions;

function register(serviceOrOpts) {
  var _a; // Is this a Service or a RegisterOptions?


  var service = serviceOrOpts;

  if (!((_a = serviceOrOpts) === null || _a === void 0 ? void 0 : _a[TS_NODE_SERVICE_BRAND])) {
    // Not a service; is options
    service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});
  }

  var originalJsHandler = require.extensions['.js'];

  var _getExtensions = getExtensions(service.config),
      tsExtensions = _getExtensions.tsExtensions,
      jsExtensions = _getExtensions.jsExtensions;

  var extensions = [].concat(_toConsumableArray(tsExtensions), _toConsumableArray(jsExtensions)); // Expose registered instance globally.

  process[exports.REGISTER_INSTANCE] = service; // Register the extensions.

  registerExtensions(service.options.preferTsExts, extensions, service, originalJsHandler);
  (0, cjs_resolve_filename_hook_1.installCommonjsResolveHookIfNecessary)(service); // Require specified modules before start-up.

  module_1.Module._preloadModules(service.options.require);

  return service;
}

exports.register = register;
/**
 * Create TypeScript compiler instance.
 */

function create() {
  var rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);
  return createFromPreloadedConfig(foundConfigResult);
}

exports.create = create;
/** @internal */

function createFromPreloadedConfig(foundConfigResult) {
  var _ref3;

  var _a, _b, _c, _d, _e;

  var configFilePath = foundConfigResult.configFilePath,
      cwd = foundConfigResult.cwd,
      options = foundConfigResult.options,
      config = foundConfigResult.config,
      compiler = foundConfigResult.compiler,
      projectLocalResolveDir = foundConfigResult.projectLocalResolveDir,
      optionBasePaths = foundConfigResult.optionBasePaths;
  var projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);
  var ts = (0, configuration_1.loadCompiler)(compiler); // Experimental REPL await is not compatible targets lower than ES2018

  var targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;

  if (options.experimentalReplAwait === true && !targetSupportsTla) {
    throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');
  } // Top-level await was added in TS 3.8


  var tsVersionSupportsTla = versionGteLt(ts.version, '3.8.0');

  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {
    throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');
  }

  var shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla; // swc implies two other options
  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line
  // So we should allow using typeCheck to override swc

  if (options.swc && !options.typeCheck) {
    if (options.transpileOnly === false) {
      throw new Error("Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.");
    }

    if (options.transpiler) {
      throw new Error("Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.");
    }
  }

  var readFile = options.readFile || ts.sys.readFile;
  var fileExists = options.fileExists || ts.sys.fileExists; // typeCheck can override transpileOnly, useful for CLI flag to override config file

  var transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;
  var transpiler = undefined;
  var transpilerBasePath = undefined;

  if (options.transpiler) {
    transpiler = options.transpiler;
    transpilerBasePath = optionBasePaths.transpiler;
  } else if (options.swc) {
    transpiler = require.resolve('./transpilers/swc.js');
    transpilerBasePath = optionBasePaths.swc;
  }

  var transformers = options.transformers || undefined;
  var diagnosticFilters = [{
    appliesToAllFiles: true,
    filenamesAbsolute: [],
    diagnosticsIgnored: [6059, 18002, 18003].concat(_toConsumableArray(options.ignoreDiagnostics || [])).map(Number)
  }];
  var configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);
  var outputCache = new Map();
  var configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;
  var scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;
  var ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;
  var isScoped = options.scope ? function (fileName) {
    return (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.';
  } : function () {
    return true;
  };
  var shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(function (str) {
    return new RegExp(str);
  }));
  var diagnosticHost = {
    getNewLine: function getNewLine() {
      return ts.sys.newLine;
    },
    getCurrentDirectory: function getCurrentDirectory() {
      return cwd;
    },
    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? function (x) {
      return x;
    } : function (x) {
      return x.toLowerCase();
    }
  };

  if (options.transpileOnly && typeof transformers === 'function') {
    throw new TypeError('Transformers function is unavailable in "--transpile-only"');
  }

  var createTranspiler;

  if (transpiler) {
    if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');
    var transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];
    var transpilerOptions = typeof transpiler === 'string' ? {} : (_d = transpiler[1]) !== null && _d !== void 0 ? _d : {};
    var transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;
    var transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);

    var transpilerFactory = require(transpilerPath).create;

    createTranspiler = function createTranspiler(compilerOptions) {
      return transpilerFactory(_objectSpread({
        service: {
          options: options,
          config: _objectSpread({}, config, {
            options: compilerOptions
          }),
          projectLocalResolveHelper: projectLocalResolveHelper
        },
        transpilerConfigLocalResolveHelper: transpilerConfigLocalResolveHelper
      }, transpilerOptions));
    };
  }
  /**
   * True if require() hooks should interop with experimental ESM loader.
   * Enabled explicitly via a flag since it is a breaking change.
   */


  var experimentalEsmLoader = false;

  function enableExperimentalEsmLoaderInterop() {
    experimentalEsmLoader = true;
  } // Install source map support and read from memory cache.


  installSourceMapSupport();

  function installSourceMapSupport() {
    var sourceMapSupport = require('@cspotcode/source-map-support');

    sourceMapSupport.install({
      environment: 'node',
      retrieveFile: function retrieveFile(pathOrUrl) {
        var _a;

        var path = pathOrUrl; // If it's a file URL, convert to local path
        // Note: fileURLToPath does not exist on early node v10
        // I could not find a way to handle non-URLs except to swallow an error

        if (experimentalEsmLoader && path.startsWith('file://')) {
          try {
            path = (0, url_1.fileURLToPath)(path);
          } catch (e) {
            /* swallow error */
          }
        }

        path = (0, util_1.normalizeSlashes)(path);
        return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';
      },
      redirectConflictingLibrary: true,
      onConflictingLibraryRedirect: function onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {
        (0, exports.debug)("Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"".concat(parent.filename, "\" attempted to require or resolve \"").concat(request, "\" and was redirected to \"").concat(redirectedRequest, "\"."));
      }
    });
  }

  var shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;
  var formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;

  function createTSError(diagnostics) {
    var diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);
    var diagnosticCodes = diagnostics.map(function (x) {
      return x.code;
    });
    return new TSError(diagnosticText, diagnosticCodes);
  }

  function reportTSError(configDiagnosticList) {
    var error = createTSError(configDiagnosticList);

    if (options.logError) {
      // Print error in red color and continue execution.
      console.error('\x1b[31m%s\x1b[0m', error);
    } else {
      // Throw error and exit the script.
      throw error;
    }
  } // Render the configuration errors.


  if (configDiagnosticList.length) reportTSError(configDiagnosticList);
  /**
   * Get the extension for a transpiled file.
   */

  var getExtension = config.options.jsx === ts.JsxEmit.Preserve ? function (path) {
    return /\.[tj]sx$/.test(path) ? '.jsx' : '.js';
  } : function (_) {
    return '.js';
  };
  /**
   * Create the basic required function using transpile mode.
   */

  var getOutput;
  var getTypeInfo;
  var getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);
  var moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({
    basePath: (_e = options.optionBasePaths) === null || _e === void 0 ? void 0 : _e.moduleTypes,
    patterns: options.moduleTypes
  }); // Use full language services when the fast option is disabled.

  if (!transpileOnly) {
    var fileContents = new Map();
    var rootFileNames = new Set(config.fileNames);
    var cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile)); // Use language services by default (TODO: invert next major version).

    if (!options.compilerHost) {
      var projectVersion = 1;
      var fileVersions = new Map(Array.from(rootFileNames).map(function (fileName) {
        return [fileName, 0];
      }));

      var getCustomTransformers = function getCustomTransformers() {
        if (typeof transformers === 'function') {
          var program = service.getProgram();
          return program ? transformers(program) : undefined;
        }

        return transformers;
      }; // Create the compiler host for type checking.


      var serviceHost = {
        getProjectVersion: function getProjectVersion() {
          return String(projectVersion);
        },
        getScriptFileNames: function getScriptFileNames() {
          return Array.from(rootFileNames);
        },
        getScriptVersion: function getScriptVersion(fileName) {
          var version = fileVersions.get(fileName);
          return version ? version.toString() : '';
        },
        getScriptSnapshot: function getScriptSnapshot(fileName) {
          // TODO ordering of this with getScriptVersion?  Should they sync up?
          var contents = fileContents.get(fileName); // Read contents into TypeScript memory cache.

          if (contents === undefined) {
            contents = cachedReadFile(fileName);
            if (contents === undefined) return;
            fileVersions.set(fileName, 1);
            fileContents.set(fileName, contents);
            projectVersion++;
          }

          return ts.ScriptSnapshot.fromString(contents);
        },
        readFile: cachedReadFile,
        readDirectory: ts.sys.readDirectory,
        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),
        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),
        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),
        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined,
        getNewLine: function getNewLine() {
          return ts.sys.newLine;
        },
        useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
          return ts.sys.useCaseSensitiveFileNames;
        },
        getCurrentDirectory: function getCurrentDirectory() {
          return cwd;
        },
        getCompilationSettings: function getCompilationSettings() {
          return config.options;
        },
        getDefaultLibFileName: function getDefaultLibFileName() {
          return ts.getDefaultLibFilePath(config.options);
        },
        getCustomTransformers: getCustomTransformers,
        trace: options.tsTrace
      };

      var _ref = (0, resolver_functions_1.createResolverFunctions)({
        host: serviceHost,
        getCanonicalFileName: getCanonicalFileName,
        ts: ts,
        cwd: cwd,
        config: config,
        projectLocalResolveHelper: projectLocalResolveHelper
      }),
          resolveModuleNames = _ref.resolveModuleNames,
          getResolvedModuleWithFailedLookupLocationsFromCache = _ref.getResolvedModuleWithFailedLookupLocationsFromCache,
          resolveTypeReferenceDirectives = _ref.resolveTypeReferenceDirectives,
          isFileKnownToBeInternal = _ref.isFileKnownToBeInternal,
          markBucketOfFilenameInternal = _ref.markBucketOfFilenameInternal;

      serviceHost.resolveModuleNames = resolveModuleNames;
      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;
      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;
      var registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);
      var service = ts.createLanguageService(serviceHost, registry);

      var updateMemoryCache = function updateMemoryCache(contents, fileName) {
        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,
        // or to trigger a re-classification of files from external to internal.
        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {
          markBucketOfFilenameInternal(fileName);
          rootFileNames.add(fileName); // Increment project version for every change to rootFileNames.

          projectVersion++;
        }

        var previousVersion = fileVersions.get(fileName) || 0;
        var previousContents = fileContents.get(fileName); // Avoid incrementing cache when nothing has changed.

        if (contents !== previousContents) {
          fileVersions.set(fileName, previousVersion + 1);
          fileContents.set(fileName, contents); // Increment project version for every file change.

          projectVersion++;
        }
      };

      var previousProgram = undefined;

      getOutput = function getOutput(code, fileName) {
        updateMemoryCache(code, fileName);
        var programBefore = service.getProgram();

        if (programBefore !== previousProgram) {
          (0, exports.debug)("compiler rebuilt Program instance when getting output for ".concat(fileName));
        }

        var output = service.getEmitOutput(fileName); // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.

        var diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));
        var programAfter = service.getProgram();
        (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);
        previousProgram = programAfter;
        var diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
        if (diagnosticList.length) reportTSError(diagnosticList);

        if (output.emitSkipped) {
          return [undefined, undefined, true];
        } // Throw an error when requiring `.d.ts` files.


        if (output.outputFiles.length === 0) {
          throw new TypeError("Unable to require file: ".concat((0, path_1.relative)(cwd, fileName), "\n") + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');
        }

        return [output.outputFiles[1].text, output.outputFiles[0].text, false];
      };

      getTypeInfo = function getTypeInfo(code, fileName, position) {
        updateMemoryCache(code, fileName);
        var info = service.getQuickInfoAtPosition(fileName, position);
        var name = ts.displayPartsToString(info ? info.displayParts : []);
        var comment = ts.displayPartsToString(info ? info.documentation : []);
        return {
          name: name,
          comment: comment
        };
      };
    } else {
      var sys = _objectSpread({}, ts.sys, {}, diagnosticHost, {
        readFile: function readFile(fileName) {
          var cacheContents = fileContents.get(fileName);
          if (cacheContents !== undefined) return cacheContents;
          var contents = cachedReadFile(fileName);
          if (contents) fileContents.set(fileName, contents);
          return contents;
        },
        readDirectory: ts.sys.readDirectory,
        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),
        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),
        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),
        resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),
        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined
      });

      var host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : _objectSpread({}, sys, {
        getSourceFile: function getSourceFile(fileName, languageVersion) {
          var contents = sys.readFile(fileName);
          if (contents === undefined) return;
          return ts.createSourceFile(fileName, contents, languageVersion);
        },
        getDefaultLibLocation: function getDefaultLibLocation() {
          return (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler));
        },
        getDefaultLibFileName: function getDefaultLibFileName() {
          return (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options)));
        },
        useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {
          return sys.useCaseSensitiveFileNames;
        }
      });
      host.trace = options.tsTrace;

      var _ref2 = (0, resolver_functions_1.createResolverFunctions)({
        host: host,
        cwd: cwd,
        config: config,
        ts: ts,
        getCanonicalFileName: getCanonicalFileName,
        projectLocalResolveHelper: projectLocalResolveHelper
      }),
          _resolveModuleNames = _ref2.resolveModuleNames,
          _resolveTypeReferenceDirectives = _ref2.resolveTypeReferenceDirectives,
          _isFileKnownToBeInternal = _ref2.isFileKnownToBeInternal,
          _markBucketOfFilenameInternal = _ref2.markBucketOfFilenameInternal;

      host.resolveModuleNames = _resolveModuleNames;
      host.resolveTypeReferenceDirectives = _resolveTypeReferenceDirectives; // Fallback for older TypeScript releases without incremental API.

      var builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({
        rootNames: Array.from(rootFileNames),
        options: config.options,
        host: host,
        configFileParsingDiagnostics: config.errors,
        projectReferences: config.projectReferences
      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences); // Read and cache custom transformers.

      var customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers; // Set the file contents into cache manually.

      var _updateMemoryCache = function _updateMemoryCache(contents, fileName) {
        var previousContents = fileContents.get(fileName);
        var contentsChanged = previousContents !== contents;

        if (contentsChanged) {
          fileContents.set(fileName, contents);
        } // Add to `rootFiles` when discovered by compiler for the first time.


        var addedToRootFileNames = false;

        if (!rootFileNames.has(fileName) && !_isFileKnownToBeInternal(fileName)) {
          _markBucketOfFilenameInternal(fileName);

          rootFileNames.add(fileName);
          addedToRootFileNames = true;
        } // Update program when file changes.


        if (addedToRootFileNames || contentsChanged) {
          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);
        }
      };

      getOutput = function getOutput(code, fileName) {
        var outText = '';
        var outMap = '';

        _updateMemoryCache(code, fileName);

        var sourceFile = builderProgram.getSourceFile(fileName);
        if (!sourceFile) throw new TypeError("Unable to read file: ".concat(fileName));
        var program = builderProgram.getProgram();
        var diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);
        var diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);
        if (diagnosticList.length) reportTSError(diagnosticList);
        var result = builderProgram.emit(sourceFile, function (path, file, writeByteOrderMark) {
          if (path.endsWith('.map')) {
            outMap = file;
          } else {
            outText = file;
          }

          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);
        }, undefined, undefined, customTransformers);

        if (result.emitSkipped) {
          return [undefined, undefined, true];
        } // Throw an error when requiring files that cannot be compiled.


        if (outText === '') {
          if (program.isSourceFileFromExternalLibrary(sourceFile)) {
            throw new TypeError("Unable to compile file from external library: ".concat((0, path_1.relative)(cwd, fileName)));
          }

          throw new TypeError("Unable to require file: ".concat((0, path_1.relative)(cwd, fileName), "\n") + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');
        }

        return [outText, outMap, false];
      };

      getTypeInfo = function getTypeInfo(code, fileName, position) {
        _updateMemoryCache(code, fileName);

        var sourceFile = builderProgram.getSourceFile(fileName);
        if (!sourceFile) throw new TypeError("Unable to read file: ".concat(fileName));
        var node = getTokenAtPosition(ts, sourceFile, position);
        var checker = builderProgram.getProgram().getTypeChecker();
        var symbol = checker.getSymbolAtLocation(node);
        if (!symbol) return {
          name: '',
          comment: ''
        };
        var type = checker.getTypeOfSymbolAtLocation(symbol, node);
        var signatures = [].concat(_toConsumableArray(type.getConstructSignatures()), _toConsumableArray(type.getCallSignatures()));
        return {
          name: signatures.length ? signatures.map(function (x) {
            return checker.signatureToString(x);
          }).join('\n') : checker.typeToString(type),
          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])
        };
      }; // Write `.tsbuildinfo` when `--build` is enabled.


      if (options.emit && config.options.incremental) {
        process.on('exit', function () {
          // Emits `.tsbuildinfo` to filesystem.
          builderProgram.getProgram().emitBuildInfo();
        });
      }
    }
  } else {
    getOutput = createTranspileOnlyGetOutputFunction();

    getTypeInfo = function getTypeInfo() {
      throw new TypeError('Type information is unavailable in "--transpile-only"');
    };
  }

  function createTranspileOnlyGetOutputFunction(overrideModuleType) {
    var compilerOptions = _objectSpread({}, config.options);

    if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;
    var customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions);
    return function (code, fileName) {
      var result;

      if (customTranspiler) {
        result = customTranspiler.transpile(code, {
          fileName: fileName
        });
      } else {
        result = ts.transpileModule(code, {
          fileName: fileName,
          compilerOptions: compilerOptions,
          reportDiagnostics: true,
          transformers: transformers
        });
      }

      var diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);
      if (diagnosticList.length) reportTSError(diagnosticList);
      return [result.outputText, result.sourceMapText, false];
    };
  } // When either is undefined, it means normal `getOutput` should be used


  var getOutputForceCommonJS = config.options.module === ts.ModuleKind.CommonJS ? undefined : createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS); // [MUST_UPDATE_FOR_NEW_MODULEKIND]

  var getOutputForceESM = config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext ? undefined : // [MUST_UPDATE_FOR_NEW_MODULEKIND]
  createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);
  var getOutputTranspileOnly = createTranspileOnlyGetOutputFunction(); // Create a simple TypeScript compiler proxy.

  function compile(code, fileName) {
    var lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var normalizedFileName = (0, util_1.normalizeSlashes)(fileName);
    var classification = moduleTypeClassifier.classifyModule(normalizedFileName); // Must always call normal getOutput to throw typechecking errors

    var _getOutput = getOutput(code, normalizedFileName),
        _getOutput2 = _slicedToArray(_getOutput, 3),
        value = _getOutput2[0],
        sourceMap = _getOutput2[1],
        emitSkipped = _getOutput2[2]; // If module classification contradicts the above, call the relevant transpiler


    if (classification.moduleType === 'cjs' && getOutputForceCommonJS) {
      var _getOutputForceCommon = getOutputForceCommonJS(code, normalizedFileName);

      var _getOutputForceCommon2 = _slicedToArray(_getOutputForceCommon, 2);

      value = _getOutputForceCommon2[0];
      sourceMap = _getOutputForceCommon2[1];
    } else if (classification.moduleType === 'esm' && getOutputForceESM) {
      var _getOutputForceESM = getOutputForceESM(code, normalizedFileName);

      var _getOutputForceESM2 = _slicedToArray(_getOutputForceESM, 2);

      value = _getOutputForceESM2[0];
      sourceMap = _getOutputForceESM2[1];
    } else if (emitSkipped) {
      var _getOutputTranspileOn = getOutputTranspileOnly(code, normalizedFileName);

      var _getOutputTranspileOn2 = _slicedToArray(_getOutputTranspileOn, 2);

      value = _getOutputTranspileOn2[0];
      sourceMap = _getOutputTranspileOn2[1];
    }

    var output = updateOutput(value, normalizedFileName, sourceMap, getExtension);
    outputCache.set(normalizedFileName, {
      content: output
    });
    return output;
  }

  var active = true;

  var enabled = function enabled(_enabled) {
    return _enabled === undefined ? active : active = !!_enabled;
  };

  var extensions = getExtensions(config);

  var ignored = function ignored(fileName) {
    if (!active) return true;
    var ext = (0, path_1.extname)(fileName);

    if (extensions.tsExtensions.includes(ext) || extensions.jsExtensions.includes(ext)) {
      return !isScoped(fileName) || shouldIgnore(fileName);
    }

    return true;
  };

  function addDiagnosticFilter(filter) {
    diagnosticFilters.push(_objectSpread({}, filter, {
      filenamesAbsolute: filter.filenamesAbsolute.map(function (f) {
        return (0, util_1.normalizeSlashes)(f);
      })
    }));
  }

  return _ref3 = {}, _defineProperty(_ref3, TS_NODE_SERVICE_BRAND, true), _defineProperty(_ref3, "ts", ts), _defineProperty(_ref3, "compilerPath", compiler), _defineProperty(_ref3, "config", config), _defineProperty(_ref3, "compile", compile), _defineProperty(_ref3, "getTypeInfo", getTypeInfo), _defineProperty(_ref3, "ignored", ignored), _defineProperty(_ref3, "enabled", enabled), _defineProperty(_ref3, "options", options), _defineProperty(_ref3, "configFilePath", configFilePath), _defineProperty(_ref3, "moduleTypeClassifier", moduleTypeClassifier), _defineProperty(_ref3, "shouldReplAwait", shouldReplAwait), _defineProperty(_ref3, "addDiagnosticFilter", addDiagnosticFilter), _defineProperty(_ref3, "installSourceMapSupport", installSourceMapSupport), _defineProperty(_ref3, "enableExperimentalEsmLoaderInterop", enableExperimentalEsmLoaderInterop), _defineProperty(_ref3, "transpileOnly", transpileOnly), _defineProperty(_ref3, "projectLocalResolveHelper", projectLocalResolveHelper), _ref3;
}

exports.createFromPreloadedConfig = createFromPreloadedConfig;
/**
 * Check if the filename should be ignored.
 */

function createIgnore(ignoreBaseDir, ignore) {
  return function (fileName) {
    var relname = (0, path_1.relative)(ignoreBaseDir, fileName);
    var path = (0, util_1.normalizeSlashes)(relname);
    return ignore.some(function (x) {
      return x.test(path);
    });
  };
}
/**
 * "Refreshes" an extension on `require.extensions`.
 *
 * @param {string} ext
 */


function reorderRequireExtension(ext) {
  var old = require.extensions[ext];
  delete require.extensions[ext];
  require.extensions[ext] = old;
}
/**
 * Register the extensions to support when importing files.
 */


function registerExtensions(preferTsExts, extensions, service, originalJsHandler) {
  // Register new extensions.
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = extensions[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ext = _step.value;
      registerExtension(_ext, service, originalJsHandler);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (preferTsExts) {
    var preferredExtensions = new Set([].concat(_toConsumableArray(extensions), _toConsumableArray(Object.keys(require.extensions))));
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = preferredExtensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var ext = _step2.value;
        reorderRequireExtension(ext);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }
}
/**
 * Register the extension for node.
 */


function registerExtension(ext, service, originalHandler) {
  var old = require.extensions[ext] || originalHandler;

  require.extensions[ext] = function (m, filename) {
    if (service.ignored(filename)) return old(m, filename);
    assertScriptCanLoadAsCJS(service, m, filename);
    var _compile = m._compile;

    m._compile = function (code, fileName) {
      (0, exports.debug)('module._compile', fileName);
      var result = service.compile(code, fileName);
      return _compile.call(this, result, fileName);
    };

    return old(m, filename);
  };
}
/**
 * Update the output remapping the source map.
 */


function updateOutput(outputText, fileName, sourceMap, getExtension) {
  var base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');
  var sourceMapContent = "//# sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64Map); // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file "foo bar.tsx"
  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951

  var prefix = '//# sourceMappingURL=';
  var prefixLength = prefix.length;
  var baseName =
  /*foo.tsx*/
  (0, path_1.basename)(fileName);
  var extName =
  /*.tsx*/
  (0, path_1.extname)(fileName);
  var extension =
  /*.js*/
  getExtension(fileName);
  var sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';
  var sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;
  /*
   * Only rewrite if existing directive exists at the location we expect, to support:
   *   a) compilers that do not append a sourcemap directive
   *   b) situations where we did the math wrong
   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.
   */

  if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {
    return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;
  } // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = "/" + sourcemapFilename; return u.pathname.slice(1);


  var sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;

  if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {
    return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;
  }

  return "".concat(outputText, "\n").concat(sourceMapContent);
}
/**
 * Update the source map contents for improved output.
 */


function updateSourceMap(sourceMapText, fileName) {
  var sourceMap = JSON.parse(sourceMapText);
  sourceMap.file = fileName;
  sourceMap.sources = [fileName];
  delete sourceMap.sourceRoot;
  return JSON.stringify(sourceMap);
}
/**
 * Filter diagnostics.
 */


function filterDiagnostics(diagnostics, filters) {
  return diagnostics.filter(function (d) {
    return filters.every(function (f) {
      var _a;

      return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;
    });
  });
}
/**
 * Get token at file position.
 *
 * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731
 */


function getTokenAtPosition(ts, sourceFile, position) {
  var current = sourceFile;

  outer: while (true) {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = current.getChildren(sourceFile)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var child = _step3.value;
        var start = child.getFullStart();
        if (start > position) break;
        var end = child.getEnd();

        if (position <= end) {
          current = child;
          continue outer;
        }
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    return current;
  }
}
/**
 * Create an implementation of node's ESM loader hooks.
 *
 * This may be useful if you
 * want to wrap or compose the loader hooks to add additional functionality or
 * combine with another loader.
 *
 * Node changed the hooks API, so there are two possible APIs.  This function
 * detects your node version and returns the appropriate API.
 */


var createEsmHooks = function createEsmHooks(tsNodeService) {
  return require('./esm').createEsmHooks(tsNodeService);
};

exports.createEsmHooks = createEsmHooks;